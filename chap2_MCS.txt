## Sous-graphe Maximum Commun

### Définition

TODO : schéma MCS

Commençons par définir précisément le problème MCS.
Comme le nom l'indique, le problème MCS est un problème de recherche de la sous partie commune maximale entre deux graphes.
Dans la définition de base du MCS, le graphe commun peut être non connexe.
Les problème de recherche de sous graphe commun connexe maximal (MCCS) est un problème encore plus difficile car il impose des contraintes fortes supplémentaires.
Le problème du MCS à été prouvé NP-Complet\cite{}, ce qui empèche (en tout cas pour le moment) l'émergence d'algorithmes de résolution polynomiaux efficaces.

Dans notre cas, nous pouvons utiliser une réduction dans ce problème afin d'effectuer la recherche des monomères.
Si l'on considère qu'un monomère et un polymère sont des graphes atomiques, alors trouver une sous partie commune à ces deux graphes revient à trouver un endroit où un morceau du monomère est retrouvé dans le peptide.
En imposant des tailles minimum, nous pourrons éviter d'avoir quelques atomes communs par hasard.

Du fait de la NP-complétude du problème, trouver des solutions est très compliqué.
Il existe tout de même quelques algorithmes de résolution exacts mais la majorité des articles à propos de MCS traite d'heuristiques de résolution rapide.
Voyons ensemble ces deux catégories d'algorithmes en s'appuyant sur les reviews~\cite{}.
% Maximum common subgraph isomorphism algorithms for the matching of chemical structures
% Maximum common subgraph isomorphism algorithms and their applications in molecular science: a review


### Les méthodes de résolution exactes

Au sein des algorithmes de résolution exacte du MCS, il existe deux grandes écoles.
D'un côté certains algorithmes ne font qu'une réduction du problème en un problème de clique maximale puis résolvent ce second problème.
D'un autre côté les méthodes de résolution se basent sur des méthodes de backtracking.


#### La réduction en clique maximale

TODO : schéma clique maximale

Il est possible de réduire le problème MCS en un problème de résolution de clique maximale~\cite{}.
Une clique est un ensemble de noeuds dans un graphe tel que tous les noeuds de cet ensemble soient reliés entre eux.
Rechercher la clique maximale revient à rechercher le sous ensemble maximal de noeuds d'un graphe pour lequels tous les noeuds sont liés les uns aux autres.
Il est possible d'obtenir plusieurs cliques maximales dans un graphe.
Ce problème est également NP-Complet~\cite{}.
% The Enumeration of Maximal Cliques of Large Graphs
Les résolutions de ce problème sont toutes des dérivées de la recherche exhaustive par force brute.
Il est possible de ne pas passer par toutes les possibilités en réduisant l'espace de recherche en fonction de l'arité des noeuds ou de leur contexte local mais les algorithmes sont toujours exponentiels.
Les algorithmes les plus utilisés en pratique sont ceux qui effectuent des recherche par branch & cut avec des coupes locales intelligentes~\cite{}.
% The Worst-Case Time Complexity for Generating All Maximal Cliques

TODO : schéma graph compatibilité + résolution MCCS

Pour résoudre un MCS à partir de d'algorithmes de MCS il est nécessaire de construire un graphe de compativilité entre les deux graphes.
Un graphe de compatibilité (GC) est un graphé créé à partir du croisement de deux graphes (on prendra G et H ici).
Pour les noeuds du GC, on génère tous les couples possibles de noeuds issus de G et H dont les labels sont identiques.
Ensuite on ajoute un lien entre deux noeuds A et B de GC si les deux noeuds issus de G dans A et B sont différents et les deux noeuds de H également.
Il est à noter que cette étape ajoute beaucoup de liens dans le GC.
Lorsque l'on recherche un MCCS, il faut en plus que les noeuds issus de G et H soient voisins dans leurs graphes respectifs.

Il ne reste plus qu'à utiliser une méthode de branch & cut adaptée à la topologie des données pour pouvoir obtenir notre max-clique et ainsi notre MCS.


#### Recherche par Backtracking

TODO : schéma backtrack

La recherche par backtrack est beaucoup plus simple conceptuellement.
Un MCS est une bijectection entre deux sous ensemble de noeuds dans deux graphes distincts.
Les méthodes de backtrack essayent de construire cette bijection en ajoutant successivement des noeuds compatibles.
Lorsque l'algorithme arrive dans une impasse (plus aucune possibilité d'ajouter un couple), il revient en arrière sur une assoction puis fait un choix différent.
En sauvegardant en permanance l'ensemble qui a contenu le plus de noeuds, on obtient la clique maximale après le parcours de tout l'arbre des choix.
Encore une fois, il existe plusieurs techniques permettant des accélérations pratiques coupant des branches mais jamais l'ordre de grandeur de la complexité n'est changé.
Dans le cas des MCCS, il faut obliger une contrainte supplémentaire d'ajout de couple au sein de la bijection.
Il faut que chacun des noeuds du couple soient voisins des noeuds d'un même couple précédemment inclus dans la bijection.


Il existe d'autres méthodes exactes pour résoudre des MCS mais uniquement sur des graphes particuliers.
Par exemple, il existe une résolution polynomiale par programmation dynamique pour les graphes qui sont des arbres~\cite{}.
Cependant aucun de ces cas particuliers ne correspond à la réalité des molécules que nous allons traiter.
Nous ne détaillerons donc pas celles-ci.



### Les méthodes heuristiques

Il existe une très grande quantité d'heuristiques de résolution du MCS.
La méthode qui revient le plus souvent est une méthode de recherche par similarités locales~\cite{}.
Ce sont des méthodes employées au sein de bases de données pour rechercher des structures chimiques par ressemblance avec une requête.
Chaque molécule de la base est décomposée en un grand nombre de critère topologiques locaux et ce critères sont entrés dans un vecteur (fingerprint).
Lors d'une requête, le motif recherché est à son tour tranformé en vecteur et une mesure de similarité est effectuée avec les vecteurs en base.
Les vecteurs les plus proches sont déclarés posséder une sous partie commune.
Cette méthode ne donne aucune assurance d'obtenir des MCS mais est très rapide.
Dans notre cas, cette méthode est inutile.

D'autres méthodes sont plus proches des méthodes exactes par recherche backtracking~\cite{}.
Ici, les auteurs construisent plusieurs bijections en parallèle.
La différence avec les méthodes exacte est qu'ils ne reviennent jamais sur les décisions prises pour construire les MCS.
En permanance sont maintenues un nombre fixe de bijections.
Ces bijections ont été sélectionnées par une fonction de score comme étant celles qui avaient le plus de chance de donner un MCS.
Au final les bijections trouvées ne seront pas forcément les vrais MCS.
Cette seconde méthode est très itéressante lorsque l'on cherche un bon raport rapidité/qualité.









## Isomorphisme de sous graphe
