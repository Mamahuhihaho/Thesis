





## Isomorphisme de sous graphe

### Définition

TODO : schéma SI

Définissions précisément le problème SI.
Comme le nom l'indique, le problème SI est un problème de recherche d'un graphe dans une sous partie d'un autre.
Tout comme le MCS, le problème du SI à été prouvé NP-Complet\cite{}.

Pour notre problème, nous pouvons à nouveau effectuer une réduction vers SI puis résoudre SI.
Nous souhaitons rechercher des monomères au sein de peptides, ce qui reviendrait à chercher plusieurs fois un petit graphe atomique monomérique dans un gros graphe atomique peptidique.

Les méthodes de résolution actuelles ne sont pas très nombreuses et dérivent toutes d'u même technique de backtracking.
La pluspart de ces méthodes sont des résolutions exactes car bien que NP-complet, la résolution reste très praticable sur des graphes non répétitifs.


### L'algorithme de Ullman

TODO : figure Ullman

L'algorithme de Ullman est l'un des premiers à avoir été proposé dans les années 70~\cite{}.
Certaines de ses variantes sont toujours utilisées.
L'algorithme se base sur la matrice de compatibilité entre les graphes (voir figure TODO).
Une matrice de compatibilité est une matrice dont chaoque ligne représente les noeuds de G et chaque colonne les noeuds de H.
Une case de la matrice comporte un 1 si les labels des noeuds de la case correspondent et que le degré du noeuds de H est suppérieur ou égal au degré du noeud de G.
Pour obtenir un SI à partir de cette matrice il faut retirer des 1 jusqu'à en avoir 1 par ligne et 0 ou 1 par colonne.
L'algorithme de Ullman propose de choisir un à un les 1 à garder dans les lignes en commençant par les lignes contenant le moins de choix.
Rapidement la matrice devient creuse et les isomorphismes sont trouvés.


### Les algorithmes de backtracking classique

TODO : schéma arbre

Tout comme pour le MCS, le SI peut être résolu par un backtracking basique.
C'est la méthode majoritairement utilisée car elle fonctionne très bien en pratique et n'a pas besoin d'espace mémoire grand comme l'algorithme de Ullman.
Les algorithmes de McGregor et VF2 utilisent ce principe~\cite{}.
Les SI se forment par ajout successif de couples de noeuds compatibles avec retour en arrière si il n'est plus possible d'avoir un couple.
Ce sont ces algorithmes qui sont utilisés dans les grandes librairies logicielles de chimie comme CDK~\cite{}.

Il est à noter qu'il existe des variants heuristiques~\cite{} pour les grands graphes mais comme pour les MCS nous ne les détaillerons par car nous nous intéressons à obtenir tous les SI possibles.




## Choisir l'algorithme de recherche de monomères

Pour pouvoir rechercher les monomères nous devions choisir entre toutes les appoches algorithmiques.
Premiérement, lorsque nous recherchons un monomère dans un peptide, nous souhaitons obtenir tous les emplacements.
Nous ne sommes donc pas partit sur des approches heuristiques qui risqueraient de nous faire louper quelques résultats.
Secondement, le MCS ne parait pas très prtique dans notre cas.
En effet, les NRP regorgent de monomères proches les uns des autres.
Il n'est donc pas facile lorsque l'on obtient un résultat de savoir si la molécule trouvée est la bonne ou si c'est le monomère voisin d'un atome qui a été détecté.
Enfin, en comparant les algorithmes de recherche exacte de solutions, ceux de résolution de SI sont plus adaptés et rapide en pratique pour notre type de données.
C'est pourquoi nous avons choisi d'effectuer la recherche des monomères en utilisant l'algorithme le plus communément utilisé par la communauté : VF2.
