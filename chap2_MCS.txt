## Sous-graphe Maximum Commun

### Définition

TODO : schéma MCS

Commençons par définir précisément le problème MCS.
Comme le nom l'indique, le problème MCS est un problème de recherche de la sous partie commune maximale entre deux graphes.
Dans la définition de base du MCS, le graphe commun peut être non connexe.
Les problème de recherche de sous graphe commun connexe maximal (MCCS) est un problème encore plus difficile car il impose des contraintes fortes supplémentaires.
Le problème du MCS à été prouvé NP-Complet\cite{}, ce qui empèche (en tout cas pour le moment) l'émergence d'algorithmes de résolution polynomiaux efficaces.

Dans notre cas, nous pouvons utiliser une réduction dans ce problème afin d'effectuer la recherche des monomères.
Si l'on considère qu'un monomère et un polymère sont des graphes atomiques, alors trouver une sous partie commune à ces deux graphes revient à trouver un endroit où un morceau du monomère est retrouvé dans le peptide.
En imposant des tailles minimum, nous pourrons éviter d'avoir quelques atomes communs par hasard.

Du fait de la NP-complétude du problème, trouver des solutions est très compliqué.
Il existe tout de même quelques algorithmes de résolution exacts mais la majorité des articles à propos de MCS traite d'heuristiques de résolution rapide.
Voyons ensemble ces deux catégories d'algorithmes en s'appuyant sur les reviews~\cite{}.
% Maximum common subgraph isomorphism algorithms for the matching of chemical structures
% Maximum common subgraph isomorphism algorithms and their applications in molecular science: a review


### Les méthodes de résolution exactes

Au sein des algorithmes de résolution exacte du MCS, il existe deux grandes écoles.
D'un côté certains algorithmes ne font qu'une réduction du problème en un problème de clique maximale puis résolvent ce second problème.
D'un autre côté les méthodes de résolution se basent sur des méthodes de backtracking.


#### La réduction en clique maximale

TODO : schéma clique maximale

Il est possible de réduire le problème MCS en un problème de résolution de clique maximale~\cite{}.
Une clique est un ensemble de noeuds dans un graphe tel que tous les noeuds de cet ensemble soient reliés entre eux.
Rechercher la clique maximale revient à rechercher le sous ensemble maximal de noeuds d'un graphe pour lequels tous les noeuds sont liés les uns aux autres.
Il est possible d'obtenir plusieurs cliques maximales dans un graphe.
Ce problème est également NP-Complet~\cite{}.
% The Enumeration of Maximal Cliques of Large Graphs
Les résolutions de ce problème sont toutes des dérivées de la recherche exhaustive par force brute.
Il est possible de ne pas passer par toutes les possibilités en réduisant l'espace de recherche en fonction de l'arité des noeuds ou de leur contexte local mais les algorithmes sont toujours exponentiels.
Les algorithmes les plus utilisés en pratique sont ceux qui effectuent des recherche par branch & cut avec des coupes locales intelligentes~\cite{}.
% The Worst-Case Time Complexity for Generating All Maximal Cliques

TODO : schéma graph compatibilité + résolution MCCS

Pour résoudre un MCS à partir de d'algorithmes de MCS il est nécessaire de construire un graphe de compativilité entre les deux graphes.
Un graphe de compatibilité (GC) est un graphé créé à partir du croisement de deux graphes (on prendra G et H ici).
Pour les noeuds du GC, on génère tous les couples possibles de noeuds issus de G et H dont les labels sont identiques.
Ensuite on ajoute un lien entre deux noeuds A et B de GC si les deux noeuds issus de G dans A et B sont différents et les deux noeuds de H également.
Il est à noter que cette étape ajoute beaucoup de liens dans le GC.
Lorsque l'on recherche un MCCS, il faut en plus que les noeuds issus de G et H soient voisins dans leurs graphes respectifs.

Il ne reste plus qu'à utiliser une méthode de branch & cut adaptée à la topologie des données pour pouvoir obtenir notre max-clique et ainsi notre MCS.


#### Recherche par Backtracking

TODO : schéma backtrack

La recherche par backtrack est beaucoup plus simple conceptuellement.
Un MCS est une bijectection entre deux sous ensemble de noeuds dans deux graphes distincts.
Les méthodes de backtrack essayent de construire cette bijection en ajoutant successivement des noeuds compatibles.
Lorsque l'algorithme arrive dans une impasse (plus aucune possibilité d'ajouter un couple), il revient en arrière sur une assoction puis fait un choix différent.
En sauvegardant en permanance l'ensemble qui a contenu le plus de noeuds, on obtient la clique maximale après le parcours de tout l'arbre des choix.
Encore une fois, il existe plusieurs techniques permettant des accélérations pratiques coupant des branches mais jamais l'ordre de grandeur de la complexité n'est changé.
Dans le cas des MCCS, il faut obliger une contrainte supplémentaire d'ajout de couple au sein de la bijection.
Il faut que chacun des noeuds du couple soient voisins des noeuds d'un même couple précédemment inclus dans la bijection.


Il existe d'autres méthodes exactes pour résoudre des MCS mais uniquement sur des graphes particuliers.
Par exemple, il existe une résolution polynomiale par programmation dynamique pour les graphes qui sont des arbres~\cite{}.
Cependant aucun de ces cas particuliers ne correspond à la réalité des molécules que nous allons traiter.
Nous ne détaillerons donc pas celles-ci.



### Les méthodes heuristiques

Il existe une très grande quantité d'heuristiques de résolution du MCS.
La méthode qui revient le plus souvent est une méthode de recherche par similarités locales~\cite{}.
Ce sont des méthodes employées au sein de bases de données pour rechercher des structures chimiques par ressemblance avec une requête.
Chaque molécule de la base est décomposée en un grand nombre de critère topologiques locaux et ce critères sont entrés dans un vecteur (fingerprint).
Lors d'une requête, le motif recherché est à son tour tranformé en vecteur et une mesure de similarité est effectuée avec les vecteurs en base.
Les vecteurs les plus proches sont déclarés posséder une sous partie commune.
Cette méthode ne donne aucune assurance d'obtenir des MCS mais est très rapide.
Dans notre cas, cette méthode est inutile.

D'autres méthodes sont plus proches des méthodes exactes par recherche backtracking~\cite{}.
Ici, les auteurs construisent plusieurs bijections en parallèle.
La différence avec les méthodes exacte est qu'ils ne reviennent jamais sur les décisions prises pour construire les MCS.
En permanance sont maintenues un nombre fixe de bijections.
Ces bijections ont été sélectionnées par une fonction de score comme étant celles qui avaient le plus de chance de donner un MCS.
Au final les bijections trouvées ne seront pas forcément les vrais MCS.
Cette seconde méthode est très itéressante lorsque l'on cherche un bon raport rapidité/qualité.









## Isomorphisme de sous graphe

### Définition

TODO : schéma SI

Définissions précisément le problème SI.
Comme le nom l'indique, le problème SI est un problème de recherche d'un graphe dans une sous partie d'un autre.
Tout comme le MCS, le problème du SI à été prouvé NP-Complet\cite{}.

Pour notre problème, nous pouvons à nouveau effectuer une réduction vers SI puis résoudre SI.
Nous souhaitons rechercher des monomères au sein de peptides, ce qui reviendrait à chercher plusieurs fois un petit graphe atomique monomérique dans un gros graphe atomique peptidique.

Les méthodes de résolution actuelles ne sont pas très nombreuses et dérivent toutes d'u même technique de backtracking.
La pluspart de ces méthodes sont des résolutions exactes car bien que NP-complet, la résolution reste très praticable sur des graphes non répétitifs.


### L'algorithme de Ullman

TODO : figure Ullman

L'algorithme de Ullman est l'un des premiers à avoir été proposé dans les années 70~\cite{}.
Certaines de ses variantes sont toujours utilisées.
L'algorithme se base sur la matrice de compatibilité entre les graphes (voir figure TODO).
Une matrice de compatibilité est une matrice dont chaoque ligne représente les noeuds de G et chaque colonne les noeuds de H.
Une case de la matrice comporte un 1 si les labels des noeuds de la case correspondent et que le degré du noeuds de H est suppérieur ou égal au degré du noeud de G.
Pour obtenir un SI à partir de cette matrice il faut retirer des 1 jusqu'à en avoir 1 par ligne et 0 ou 1 par colonne.
L'algorithme de Ullman propose de choisir un à un les 1 à garder dans les lignes en commençant par les lignes contenant le moins de choix.
Rapidement la matrice devient creuse et les isomorphismes sont trouvés.


### Les algorithmes de backtracking classique

TODO : schéma arbre

Tout comme pour le MCS, le SI peut être résolu par un backtracking basique.
C'est la méthode majoritairement utilisée car elle fonctionne très bien en pratique et n'a pas besoin d'espace mémoire grand comme l'algorithme de Ullman.
Les algorithmes de McGregor et VF2 utilisent ce principe~\cite{}.
Les SI se forment par ajout successif de couples de noeuds compatibles avec retour en arrière si il n'est plus possible d'avoir un couple.
Ce sont ces algorithmes qui sont utilisés dans les grandes librairies logicielles de chimie comme CDK~\cite{}.

Il est à noter qu'il existe des variants heuristiques~\cite{} pour les grands graphes mais comme pour les MCS nous ne les détaillerons par car nous nous intéressons à obtenir tous les SI possibles.




## Choisir l'algorithme de recherche de monomères

Pour pouvoir rechercher les monomères nous devions choisir entre toutes les appoches algorithmiques.
Premiérement, lorsque nous recherchons un monomère dans un peptide, nous souhaitons obtenir tous les emplacements.
Nous ne sommes donc pas partit sur des approches heuristiques qui risqueraient de nous faire louper quelques résultats.
Secondement, le MCS ne parait pas très prtique dans notre cas.
En effet, les NRP regorgent de monomères proches les uns des autres.
Il n'est donc pas facile lorsque l'on obtient un résultat de savoir si la molécule trouvée est la bonne ou si c'est le monomère voisin d'un atome qui a été détecté.
Enfin, en comparant les algorithmes de recherche exacte de solutions, ceux de résolution de SI sont plus adaptés et rapide en pratique pour notre type de données.
C'est pourquoi nous avons choisi d'effectuer la recherche des monomères en utilisant l'algorithme le plus communément utilisé par la communauté : VF2.
